//! # F# Integration Example
//!
//! This example demonstrates the F# â†’ Rust â†’ Bevy integration workflow.
//! It shows how F# types and functions map to Rust equivalents.
//!
//! ## What You'll Learn
//!
//! - F# to Rust type mapping conventions
//! - How to prepare F# code for fsrs transpilation
//! - The workflow for updating game logic
//! - Type alignment requirements between F# and Rust
//!
//! ## Run This Example
//!
//! ```bash
//! cargo run --example fsharp_integration
//! ```
//!
//! ## Key Concepts
//!
//! The F# â†’ Rust path requires careful type alignment:
//! - F# records â†” Rust structs
//! - F# functions â†” Rust functions
//! - F# discriminated unions â†” Rust enums
//! - Naming conventions: PascalCase (F#) vs snake_case (Rust)

use bevy_wasm_fsharp_ref_logic::{Ability, Character, Stats, compute_attack};

fn main() {
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘   F# Integration Example              â•‘");
    println!("â•‘   Understanding the F# â†’ Rust Path    â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    // ====================
    // Section 1: Type Mapping
    // ====================

    println!("=== 1. F# to Rust Type Mapping ===\n");

    println!("F# Record:");
    println!("```fsharp");
    println!("type Stats =");
    println!("    {{ Hp: int");
    println!("      Attack: int");
    println!("      Defense: int }}");
    println!("```\n");

    println!("Rust Equivalent:");
    println!("```rust");
    println!("#[derive(Debug, Clone, Serialize, Deserialize)]");
    println!("pub struct Stats {{");
    println!("    pub hp: i32,      // F# Hp -> Rust hp");
    println!("    pub attack: i32,  // F# Attack -> Rust attack");
    println!("    pub defense: i32, // F# Defense -> Rust defense");
    println!("}}");
    println!("```\n");

    println!("Key Differences:");
    println!("  â€¢ F# uses PascalCase for fields â†’ Rust uses snake_case");
    println!("  â€¢ F# `int` â†’ Rust `i32`");
    println!("  â€¢ Rust requires explicit derives (Clone, Serialize, etc.)");
    println!("  â€¢ Rust needs `pub` for public visibility\n");

    // Create an instance to demonstrate
    let stats = Stats {
        hp: 30,
        attack: 10,
        defense: 2,
    };

    println!("Created Stats instance:");
    println!("  hp: {}", stats.hp);
    println!("  attack: {}", stats.attack);
    println!("  defense: {}\n", stats.defense);

    // ====================
    // Section 2: Function Mapping
    // ====================

    println!("=== 2. F# Functions â†’ Rust Functions ===\n");

    println!("F# Function:");
    println!("```fsharp");
    println!("let computeAttack (attacker: Character) (defender: Character) (ability: Ability) : CombatEvent =");
    println!("    let raw = attacker.Stats.Attack + ability.Power");
    println!("    let dmg = max 1 (raw - defender.Stats.Defense)");
    println!("    let hpAfter = defender.Hp - dmg");
    println!("    {{ AttackerName = attacker.Name");
    println!("      DefenderName = defender.Name");
    println!("      Damage = dmg");
    println!("      DefenderHpAfter = hpAfter }}");
    println!("```\n");

    println!("Rust Equivalent (auto-generated by fsrs):");
    println!("```rust");
    println!("pub fn compute_attack(");
    println!("    attacker: &Character,");
    println!("    defender: &Character,");
    println!("    ability: &Ability,");
    println!(") -> CombatEvent {{");
    println!("    let raw = attacker.stats.attack + ability.power;");
    println!("    let dmg = (raw - defender.stats.defense).max(1);");
    println!("    let hp_after = defender.hp - dmg;");
    println!("    CombatEvent {{");
    println!("        attacker_name: attacker.name.clone(),");
    println!("        defender_name: defender.name.clone(),");
    println!("        damage: dmg,");
    println!("        defender_hp_after: hp_after,");
    println!("    }}");
    println!("}}");
    println!("```\n");

    // Demonstrate the function
    let player = Character::new_player("Hero");
    let monster = Character::new_monster("Slime");
    let ability = Ability::basic_attack();

    let event = compute_attack(&player, &monster, &ability);

    println!("Function Call Result:");
    println!("  Attacker: {}", event.attacker_name);
    println!("  Defender: {}", event.defender_name);
    println!("  Damage: {}", event.damage);
    println!("  Defender HP After: {}\n", event.defender_hp_after);

    // ====================
    // Section 3: Development Workflow
    // ====================

    println!("=== 3. F# â†’ Rust Development Workflow ===\n");

    println!("Current State (v0.1):");
    println!("  1. F# source exists in fsharp/Domain.fs (type definitions)");
    println!("  2. Rust code is hand-written in crates/logic-fsharp/src/lib.rs");
    println!("  3. Types must be manually kept in sync\n");

    println!("Future State (when fsrs is integrated):");
    println!("  1. Write F# code in fsharp/Domain.fs and fsharp/GameLogic.fs");
    println!("  2. Run fsrs transpiler:");
    println!("     $ fable fsharp/GameLogic.fs --lang rust --outDir crates/logic-fsharp/src/");
    println!("  3. Rust code is auto-generated (no manual sync needed!)");
    println!("  4. Bevy app imports and uses the generated Rust code\n");

    println!("Workflow Commands:");
    println!("  # Edit F# logic");
    println!("  $ vim fsharp/GameLogic.fs");
    println!();
    println!("  # Transpile to Rust (future)");
    println!("  $ fable fsharp/GameLogic.fs --lang rust --outDir crates/logic-fsharp/src/");
    println!();
    println!("  # Build and test");
    println!("  $ cargo run -p app");
    println!();
    println!("  # Run tests");
    println!("  $ cargo test -p logic-fsharp\n");

    // ====================
    // Section 4: Type Safety Benefits
    // ====================

    println!("=== 4. Type Safety Benefits ===\n");

    println!("Both F# and Rust enforce strong typing:");
    println!();
    println!("âœ“ Compile-time error detection");
    println!("  - Invalid field access caught at compile time");
    println!("  - Type mismatches prevented");
    println!("  - Null/None handling enforced\n");

    println!("âœ“ Refactoring safety");
    println!("  - Change a type in F#");
    println!("  - Transpile to Rust");
    println!("  - Compiler shows all affected locations\n");

    println!("âœ“ Cross-language consistency");
    println!("  - F# type checker validates logic");
    println!("  - Rust type checker validates integration");
    println!("  - Both catch different classes of bugs\n");

    // Demonstrate type-safe computation
    println!("Example: Type-safe damage calculation");

    let warrior = Character {
        name: "Warrior".to_string(),
        hp: 50,
        stats: Stats {
            hp: 50,
            attack: 15,
            defense: 5,
        },
    };

    let dragon = Character {
        name: "Dragon".to_string(),
        hp: 100,
        stats: Stats {
            hp: 100,
            attack: 20,
            defense: 8,
        },
    };

    let power_ability = Ability {
        name: "Power Strike".to_string(),
        power: 10,
    };

    let event = compute_attack(&warrior, &dragon, &power_ability);

    println!("  Warrior (ATK: {}) + Power Strike (Power: {}) - Dragon (DEF: {})",
        warrior.stats.attack, power_ability.power, dragon.stats.defense);
    println!("  = {} damage", event.damage);
    println!("  Dragon HP: {} â†’ {}\n", dragon.hp, event.defender_hp_after);

    // ====================
    // Section 5: Adding New Features
    // ====================

    println!("=== 5. Adding New Features ===\n");

    println!("To add a new feature (e.g., Critical Hits):\n");

    println!("Step 1: Define in F# (fsharp/GameLogic.fs)");
    println!("```fsharp");
    println!("let criticalChance = 0.15  // 15% crit chance");
    println!();
    println!("let computeAttackWithCrit (attacker: Character) (defender: Character) (ability: Ability) (rng: float) : CombatEvent =");
    println!("    let raw = attacker.Stats.Attack + ability.Power");
    println!("    let isCrit = rng < criticalChance");
    println!("    let multiplier = if isCrit then 2.0 else 1.0");
    println!("    let dmg = max 1 (int (float (raw - defender.Stats.Defense) * multiplier))");
    println!("    let hpAfter = defender.Hp - dmg");
    println!("    {{ AttackerName = attacker.Name");
    println!("      DefenderName = defender.Name");
    println!("      Damage = dmg");
    println!("      DefenderHpAfter = hpAfter }}");
    println!("```\n");

    println!("Step 2: Transpile to Rust (automatic with fsrs)");
    println!("  The F# code above becomes Rust code with matching logic\n");

    println!("Step 3: Use in Bevy");
    println!("```rust");
    println!("fn combat_system(mut query: Query<&mut Character>) {{");
    println!("    let rng = random::<f64>();");
    println!("    let event = compute_attack_with_crit(&attacker, &defender, &ability, rng);");
    println!("    // ... apply damage");
    println!("}}");
    println!("```\n");

    // ====================
    // Section 6: Testing
    // ====================

    println!("=== 6. Testing Strategy ===\n");

    println!("F# Side:");
    println!("  - Use F# unit tests (Expecto, NUnit)");
    println!("  - Test pure logic functions");
    println!("  - Validate game rules\n");

    println!("Rust Side:");
    println!("  - Use #[cfg(test)] modules");
    println!("  - Test transpiled functions");
    println!("  - Integration tests with Bevy\n");

    println!("Example Rust Test:");
    println!("```rust");
    println!("#[cfg(test)]");
    println!("mod tests {{");
    println!("    use super::*;");
    println!();
    println!("    #[test]");
    println!("    fn test_compute_attack_basic() {{");
    println!("        let player = Character::new_player(\"Test\");");
    println!("        let monster = Character::new_monster(\"Test\");");
    println!("        let ability = Ability::basic_attack();");
    println!("        let event = compute_attack(&player, &monster, &ability);");
    println!("        assert_eq!(event.damage, 14); // 10 + 5 - 1");
    println!("    }}");
    println!("}}");
    println!("```\n");

    println!("Run tests:");
    println!("  $ cargo test -p logic-fsharp\n");

    // ====================
    // Conclusion
    // ====================

    println!("=== Summary ===\n");
    println!("The F# â†’ Rust â†’ Bevy path provides:");
    println!("  âœ“ Type safety at every stage");
    println!("  âœ“ Functional programming for game logic");
    println!("  âœ“ High-performance Rust execution");
    println!("  âœ“ Cross-platform deployment (native + WASM)");
    println!("  âœ“ Clear separation: logic (F#) vs rendering (Bevy)\n");

    println!("ðŸ“š Next Steps:");
    println!("  - Read fsharp/Domain.fs to see F# type definitions");
    println!("  - Read crates/logic-fsharp/src/lib.rs to see Rust equivalents");
    println!("  - Explore docs/fsharp-integration.md for detailed guide");
    println!("  - Try: cargo run --example headless_simulation");
}
